<!DOCTYPE html>
<html lang="ms">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Stack Games PRO</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #fff;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    canvas {
      border: 2px solid #444;
      border-radius: 8px;
      background: #000;
      margin-top: 20px;
    }
    #ui {
      margin-top: 15px;
      display: flex;
      gap: 10px;
    }
    button {
      padding: 10px 16px;
      background:#333;
      color:#fff;
      border:none;
      border-radius:6px;
      cursor:pointer;
      font-size:16px;
    }
    button:hover { background:#555; }

    #mobileControls {
      display:flex;
      gap:10px;
      margin-top:15px;
    }
    #mobileControls button {
      font-size:22px;
      padding:12px 20px;
    }

    #scoreBox {
      margin-top:10px;
      font-size:18px;
    }
  </style>
</head>

<body>

<h2>Stack Games PRO</h2>
<canvas id="gameCanvas" width="300" height="500"></canvas>

<div id="scoreBox">
  Score: <span id="score">0</span> |  
  Highscore: <span id="highscore">0</span>
</div>

<div id="ui">
  <button onclick="goHome()">Home</button>
  <button onclick="togglePause()">Pause</button>
  <button onclick="restartGame()">Restart</button>
  <button onclick="toggleFullscreen()">Fullscreen</button>
</div>

<div id="mobileControls">
  <button onclick="move(-1)">‚óÄÔ∏è</button>
  <button onclick="rotate()">üîÑ</button>
  <button onclick="move(1)">‚ñ∂Ô∏è</button>
  <button onclick="drop()">‚¨áÔ∏è</button>
  <button onclick="hardDrop()">‚è¨</button>
</div>


<script>
// =====================
// SOUND
// =====================
const sndDrop   = new Audio('sounds/drop.mp3');
const sndClear  = new Audio('sounds/clear.mp3');
const sndRotate = new Audio('sounds/rotate.mp3');
const sndOver   = new Audio('sounds/gameover.mp3');

// =====================
// GAME ENGINE
// =====================
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const COLS = 10;
const ROWS = 20;
const BLOCK = 25;

let grid = [];
let currentPiece;
let ghostPiece;
let dropCounter = 0;
let dropInterval = 550;
let lastTime = 0;
let paused = false;
let score = 0;

// Tetromino shapes
const shapes = [
  [[1,1,1,1]],
  [[1,1],[1,1]],
  [[0,1,0],[1,1,1]],
  [[1,0,0],[1,1,1]],
  [[0,0,1],[1,1,1]]
];

function resetGrid(){
  grid = Array.from({length: ROWS},()=>Array(COLS).fill(0));
}

function randomColor(){
  return `hsl(${Math.random()*360},70%,60%)`;
}

// ============ GHOST PIECE ============
function createGhost() {
  ghostPiece = JSON.parse(JSON.stringify(currentPiece));
  while(!collide(grid, ghostPiece)) {
    ghostPiece.y++;
  }
  ghostPiece.y--; 
}

// ============ NEW PIECE ============
function newPiece(){
  const shape = shapes[Math.floor(Math.random()*shapes.length)];
  return {
    matrix: shape,
    x: 3,
    y: 0,
    color: randomColor()
  };
}

// ============ FIXED COLLISION ============
function collide(grid, piece) {
  for (let y = 0; y < piece.matrix.length; y++) {
    for (let x = 0; x < piece.matrix[y].length; x++) {
      if (piece.matrix[y][x] !== 0) {

        if (piece.x + x < 0 || piece.x + x > COLS - 1) return true;

        if (piece.y + y >= ROWS) return true;

        if (grid[piece.y + y][piece.x + x] !== 0) return true;
      }
    }
  }
  return false;
}

// ============ MERGE GRID ============
function merge(grid,piece){
  piece.matrix.forEach((row,y)=>{
    row.forEach((val,x)=>{
      if(val){
        grid[piece.y+y][piece.x+x] = piece.color;
      }
    });
  });
}

// ============ CLEAR LINES ============
function clearLines(){
  let lines = 0;
  for(let y=ROWS-1; y>=0; y--){
    if(grid[y].every(v=>v!==0)){
      grid.splice(y,1);
      grid.unshift(Array(COLS).fill(0));
      sndClear.play();
      lines++;
    }
  }

  if(lines > 0){
    score += lines * 100;
    updateScore();
  }
}

// ============ DRAW ============
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // GRID
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      if(grid[y][x]){
        ctx.fillStyle = grid[y][x];
        ctx.globalAlpha = 1;
        ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);
      }
    }
  }

  // GHOST PIECE
  if(ghostPiece){
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = currentPiece.color;
    ghostPiece.matrix.forEach((row,y)=>{
      row.forEach((val,x)=>{
        if(val){
          ctx.fillRect((ghostPiece.x+x)*BLOCK,(ghostPiece.y+y)*BLOCK,BLOCK,BLOCK);
        }
      });
    });
  }

  // CURRENT PIECE
  ctx.globalAlpha = 1;
  currentPiece.matrix.forEach((row,y)=>{
    row.forEach((val,x)=>{
      if(val){
        ctx.fillStyle = currentPiece.color;
        ctx.fillRect((currentPiece.x+x)*BLOCK,(currentPiece.y+y)*BLOCK,BLOCK,BLOCK);
      }
    });
  });
}

// ============ DROP ============
function drop(){
  currentPiece.y++;
  if(collide(grid,currentPiece)){
    currentPiece.y--;
    sndDrop.play();
    merge(grid,currentPiece);
    clearLines();
    currentPiece = newPiece();
    createGhost();

    if(collide(grid,currentPiece)){
      sndOver.play();
      alert("Game Over Bro!");
      restartGame();
    }
  }
  createGhost();
}

// ============ HARD DROP ============
function hardDrop(){
  while(!collide(grid,currentPiece)){
    currentPiece.y++;
  }
  currentPiece.y--;
  drop();
}

// ============ MOVEMENT ============
function move(dir){
  currentPiece.x += dir;
  if(collide(grid,currentPiece)) currentPiece.x -= dir;
  // simple wall kick (optional)
    if (!collide(grid, currentPiece)) return;
  createGhost();

  if(vibrate) navigator.vibrate(15);
}

// ============ ROTATE ============
function rotate(){
  const m = currentPiece.matrix;
  const rotated = m[0].map((_,i)=>m.map(r=>r[i])).reverse();
  const old = currentPiece.matrix;
  currentPiece.matrix = rotated;

  if(collide(grid,currentPiece)) currentPiece.matrix = old;
  else sndRotate.play();

  createGhost();
}

// ============ UPDATE LOOP ============
function update(time=0){
  if(!paused){
    const delta = time - lastTime;
    lastTime = time;

    dropCounter += delta;
    if(dropCounter > dropInterval){
      drop();
      dropCounter = 0;
    }

    draw();
  }
  requestAnimationFrame(update);
}

function restartGame(){
  score = 0;
  updateScore();
  resetGrid();
  currentPiece = newPiece();
  createGhost();
}

function togglePause(){ paused = !paused; }

function goHome(){ window.location.href  = "index.html"; }

function toggleFullscreen(){
  if(!document.fullscreenElement) canvas.requestFullscreen();
  else document.exitFullscreen();
}

function updateScore(){
  document.getElementById("score").textContent = score;

  if(score > highscore){
    localStorage.setItem("stackHighscore", score);
    document.getElementById("highscore").textContent = score;
  }
}

// HIGH SCORE INIT
let highscore = localStorage.getItem("stackHighscore") || 0;
document.getElementById("highscore").textContent = highscore;

// START GAME
resetGrid();
currentPiece = newPiece();
createGhost();
update();

// Keyboard
document.addEventListener("keydown", e =>{
  if(paused) return;
  if(e.key === "ArrowLeft") move(-1);
  if(e.key === "ArrowRight") move(1);
  if(e.key === "ArrowDown") drop();
  if(e.key === "ArrowUp") rotate();
  if(e.key === " ") hardDrop();
});

// Mobile haptic
const vibrate = "vibrate" in navigator;
</script>

</body>
</html>
