<!DOCTYPE html>
<html lang="ms">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Stack Games</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #fff;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    canvas {
      border: 2px solid #444;
      border-radius: 8px;
      background: #000;
      margin-top: 20px;
    }
    #ui {
      margin-top: 15px;
      display: flex;
      gap: 10px;
    }
    button {
      padding: 8px 14px;
      background:#333;
      color:#fff;
      border:none;
      border-radius:6px;
      cursor:pointer;
    }
    button:hover{
      background:#555;
    }
  </style>
</head>
<body>

  <h2>Stack Games</h2>
  <canvas id="gameCanvas" width="300" height="500"></canvas>

  <div id="ui">
    <button onclick="goHome()">Home</button>
    <button onclick="togglePause()">Pause</button>
    <button onclick="restartGame()">Restart</button>
    <button onclick="toggleFullscreen()">Fullscreen</button>
  </div>
  <div id="mobileControls">
  <button onclick="move(-1)">‚óÄÔ∏è</button>
  <button onclick="rotate()">üîÑ</button>
  <button onclick="move(1)">‚ñ∂Ô∏è</button>
  <button onclick="drop()">‚¨áÔ∏è</button>
</div>


<script>
// =====================
// üîä SOUND
// =====================
const sndDrop   = new Audio('sounds/drop.mp3');
const sndClear  = new Audio('sounds/clear.mp3');
const sndRotate = new Audio('sounds/rotate.mp3');
const sndOver   = new Audio('sounds/gameover.mp3');

// =====================
// üéÆ GAME ENGINE
// =====================
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const COLS = 10;
const ROWS = 20;
const BLOCK = 25;

let grid = [];
let currentPiece;
let dropCounter = 0;
let dropInterval = 500;
let lastTime = 0;
let paused = false;

// SHAPES
const shapes = [
  [[1,1,1,1]],
  [[1,1],[1,1]],
  [[0,1,0],[1,1,1]],
  [[1,0,0],[1,1,1]],
  [[0,0,1],[1,1,1]]
];

function resetGrid(){
  grid = Array.from({length: ROWS},()=>Array(COLS).fill(0));
}

function randomColor(){
  return `hsl(${Math.random()*360},70%,60%)`;
}

function newPiece(){
  const shape = shapes[Math.floor(Math.random()*shapes.length)];
  return {
    matrix: shape,
    x: 3,
    y: 0,
    color: randomColor()
  };
}

function collide(grid,piece){
  for(let y=0;y<piece.matrix.length;y++){
    for(let x=0;x<piece.matrix[y].length;x++){
      if(piece.matrix[y][x] &&
        (grid[piece.y+y] && grid[piece.y+y][piece.x+x]) !== 0){
        return true;
      }
    }
  }
  return false;
}

function merge(grid,piece){
  piece.matrix.forEach((row,y)=>{
    row.forEach((val,x)=>{
      if(val){
        grid[piece.y+y][piece.x+x] = piece.color;
      }
    });
  });
}

function clearLines(){
  for(let y=ROWS-1; y>=0; y--){
    if(grid[y].every(v=>v!==0)){
      grid.splice(y,1);
      grid.unshift(Array(COLS).fill(0));
      sndClear.play();
    }
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // GRID
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      if(grid[y][x]){
        ctx.fillStyle = grid[y][x];
        ctx.globalAlpha = 0.9;
        ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);
      }
    }
  }

  // CURRENT PIECE
  if(currentPiece){
    currentPiece.matrix.forEach((row,y)=>{
      row.forEach((val,x)=>{
        if(val){
          ctx.fillStyle = currentPiece.color;
          ctx.fillRect((currentPiece.x+x)*BLOCK,(currentPiece.y+y)*BLOCK,BLOCK,BLOCK);
        }
      });
    });
  }
}

function drop(){
  currentPiece.y++;
  if(collide(grid,currentPiece)){
    currentPiece.y--;
    sndDrop.play();
    merge(grid,currentPiece);
    clearLines();
    currentPiece = newPiece();
    if(collide(grid,currentPiece)){
      sndOver.play();
      alert("Game Over Bro!");
      restartGame();
    }
  }
}

function update(time=0){
  if(!paused){
    const delta = time - lastTime;
    lastTime = time;

    dropCounter += delta;
    if(dropCounter > dropInterval){
      drop();
      dropCounter = 0;
    }

    draw();
  }
  requestAnimationFrame(update);
}

function move(dir){
  currentPiece.x += dir;
  if(collide(grid,currentPiece)) currentPiece.x -= dir;
}

function rotate(){
  const m = currentPiece.matrix;
  const rotated = m[0].map((_,i)=>m.map(r=>r[i])).reverse();
  const old = currentPiece.matrix;
  currentPiece.matrix = rotated;

  if(collide(grid,currentPiece)){
    currentPiece.matrix = old;  
  } else {
    sndRotate.play();
  }
}

document.addEventListener("keydown", e =>{
  if(paused) return;

  if(e.key === "ArrowLeft") move(-1);
  if(e.key === "ArrowRight") move(1);
  if(e.key === "ArrowDown") drop();
  if(e.key === "ArrowUp") rotate();
});

function restartGame(){
  resetGrid();
  currentPiece = newPiece();
}

function togglePause(){ paused = !paused; }

function goHome(){ window.location.href = "index.html"; }

function toggleFullscreen(){
  if(!document.fullscreenElement) canvas.requestFullscreen();
  else document.exitFullscreen();
}

// START GAME
resetGrid();
currentPiece = newPiece();
update();
</script>

</body>
</html>
